<!doctype html>
<html>
<head>
  <title>World Chunks Map</title>
</head>
<body>
    <svg id="overWorld"xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:cc="http://web.resource.org/cc/"
    xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
    version="1.1"></svg>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
    <script>
        (function() {
            'use strict';
            // Fetch keys from API. This is the only data needed for the chunk map.
            d3.json("http://127.0.0.1:8080/api/v1/db/", function(error, keyList){
                if (error) {
                    return console.warn(error);
                }
                console.log("Key list retrieved");
                let chunkList = {};
                // Iterate over keys, add subchunk keys to chunkList data/count
                keyList.keys.forEach(function(e, i) {
                    // Matches overworld subchunks ................2f..
                    if (/^[\da-f]{16}2f[\da-f]{2}/.test(e.hexKey)) {
                        let myChunk = e.hexKey.substring(0,16);
                        if (chunkList[myChunk]) {
                            // If it exists, increment subchunks counter
                            chunkList[myChunk].subchunks += 1;
                        } else {
                            // create array so buffer.slice is available
                            var byteArrayKey = new Uint8Array(e.hexKey.length / 2);
                            // populate the array
                            for (var i = 0; i < e.hexKey.length; i += 2) {
                                byteArrayKey[i/2] = parseInt("0x" + e.hexKey.substr(i, 2), 16);
                            }
                            chunkList[myChunk] = {
                                "subchunks": 1,
                                "x": new Int32Array((new Uint8Array(byteArrayKey)).buffer.slice(0,4))[0],
                                "z": new Int32Array((new Uint8Array(byteArrayKey)).buffer.slice(4,8))[0]
                            };
                        }
                    }
                });
                // Make Array from chunkList hash data for use in d3.js
                let chunkArray = [];
                for (let prop in chunkList) {
                        chunkList[prop]["hexKey"] = prop;
                        chunkArray.push(chunkList[prop]);
                }
                // unitSize isn't really necessary; I put it in while trying to figure out SVG scaling
                //   It could also be useful if I wanted to overlay a block map on top of this for matching scale
                let unitSize = 16
                // Finding min and max coordinates to set SVG viewBox origin and size for scaling and centering
                let xMin = Math.min(...chunkArray.map(x => x.x)) * unitSize;
                let zMin = Math.min(...chunkArray.map(x => x.z)) * unitSize;
                let xSize = Math.max(...chunkArray.map(x => x.x)) * unitSize - xMin;
                let zSize = Math.max(...chunkArray.map(x => x.z)) * unitSize - zMin;
                // standard d3.js magic follows
                // set attributes son element svg with id overWorld, create a reference variable
                let svg = d3.select("svg#overWorld")
                    .attr("viewBox", xMin.toString(10) + " " + zMin.toString(10)+ " " + xSize.toString(10)+ " " + zSize.toString(10))
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    // .attr("width", "800")
                    .attr("height", "auto")
                    ;
                // add <g> elements, one for each chunkArray element with data attached
                let chunks = svg.selectAll("g")
                    .data(chunkArray)
                    .enter()
                    .append("g")
                    ;
                // create <title> elements for browser hover tooltip
                chunks.append("title")
                    .text(function(e){ return `${e.hexKey}\nchunk x,z ${e.x}, ${e.z}\nworld x,z ${e.x * 16}, ${e.z * 16}\nsubchunks ${e.subchunks}` ; })
                    ;
                // create square to represent chunk
                chunks.append("rect")
                    .attr("x", function(e){ return e.x * unitSize; })
                    .attr("y", function(e){ return e.z * unitSize; })
                    .attr("width", function(e){ return unitSize *0.8; })
                    .attr("height", function(e){ return unitSize *0.8; })
                    ;
                
            });
        })();
    </script>
</body>
</html>